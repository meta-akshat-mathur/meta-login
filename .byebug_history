c
@resource.confirmed?
c
@resource.user_logins
@resource.provider
@resource
c
@resource
c
@resource
c
@resource
c
q
c
cc
c
@resource
c
@resource
c
resource_class
c
opts
@opts
c
opts
c
@resource
@opts
c
params[:provider]
params[:email]
params[:redirect_url]
@redirect_url
@config
config
@resource
c
token
opts[:client_config]
opts
c
opts
c
@resource
c
@resource
c
down
user
down
user
down
user
down
@resource
down
@resource
down
c
opts[:client_config] 
token
down
donw
opts
c
@resource
c
request.headers[uid_name]
@resource_params
@resource
"BINARY uid = ? AND provider='email'"
ActiveRecord::Base.connection.adapter_name.downcase.starts_with? 'mysql'
q
c
DeviseTokenAuth.headers_names[:'access-token']
rc
request.headers[provider_name]
down
mapping
c
@auth_params
@resource
c
down
c
@resource.provider
@resource
c
resource_class(mapping)
rc
@resource
c
@auth_params
@resource
c
@resource
c
@resource
c
@resource
c
user
c
user.firstc
user.first
user
uid && User.joins(:user_logins).select('*',"user_logins.id as user_login_id","users.id as id").where('user_logins.provider = ? AND user_logins.uid = ?', provider,uid)
uid
user.method
user.methods
user.instance_methods
user.valid_token?
user
c
@resource
c
rc
user.valid_token?(@token, @client_id)
user
user.instance_methods
@client_id
@token
user.methods
user.instance_methods
user
@resource
user.valid_token?(@token, @client_id)
user
c
n
c
n
c
n
c
n
c
@resource
c
@resource
c
down
up
down
up
@resource
c
@resource
c
@resource
c
@resource
@resource.build_auth_header(@token, @client_id)
c
 @resource.reload.tokens[@client_id].nil?
@used_auth_by_token and not DeviseTokenAuth.change_headers_on_each_request
@resource
c
@resource
c
@resource
c
@resource
@used_auth_by_token and not DeviseTokenAuth.change_headers_on_each_request
@used_auth_by_token
c
@resource
c
@resource
c
@resource
@resource.build_auth_header(@token, @client_id)
auth_header = @resource.build_auth_header(@token, @client_id)
c
@resource.build_auth_header(@token, @client_id)
@resource
@used_auth_by_token
@used_auth_by_token and not DeviseTokenAuth.change_headers_on_each_request
DeviseTokenAuth.change_headers_on_each_request
c
DeviseTokenAuth.change_headers_on_each_request
c
user
c
@token
c
@token
c
return false unless @token
retuen false unless @token
unless @token
c
@token
c
@token
c
@resource.token_validation_response
@resource.token_validation_responce
@resource
c
self
render_create_success
yield if block_given?
c
@resource
@resource.save
sign_in(:user, @resource, store: false, bypass: false)
c
@resource && (@resource.class == rc)
(@resource.class == rc)
@resource && (@resource.class == rc)
@resource
c
@resource
c
@resource
c
current_user
sign_in(:user, @resource, store: false, bypass: false)
@resource
:user
c
down
user
down
user
down
c
current_user
self
self.uid
c
@resource
c
@resource
c
@resource
self.provider
current_user
self
c
resource_class.joins(:user_logins).joins(:user_logins).select('*',"user_logins.id as user_login_id","users.id as id").where('user_logins.uid = ?', q_value).where(q, q_value).first
@resource
q_value
@resource
c
                @resource = resource_class.joins(:user_logins).joins(:user_logins).select('*',"user_logins.id as user_login_id","users.id as id").where('user_logins.uid = ?', q_value).where(q, q_value).first
                @resource = resource_class.joins(:user_logins)..j                @resource = resource_class.joins(:user_logins).joins(:user_logins).select('*',"user_logins.id as user_login_id","users.id as id").where('user_logins.uid = ?', q_value).where(q, q_value).firstoins(:user_logins).select('*',"user_logins.id as user_login_id","users.id as id").where('user_logins.uid = ?', q_value).where(q, q_value).first
                @resource = resource_class.joins(:user_logins)..joins(:user_logins).select('*',"user_logins.id as user_login_id","users.id as id").where('user_logins.uid = ?', q_value).where(q, q_value).first
resource_params
field
@client_id
@resource
c
